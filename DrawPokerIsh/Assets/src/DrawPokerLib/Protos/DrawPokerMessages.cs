// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DrawPokerMessages.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Protobuf.DrawPoker {

  /// <summary>Holder for reflection information generated from DrawPokerMessages.proto</summary>
  public static partial class DrawPokerMessagesReflection {

    #region Descriptor
    /// <summary>File descriptor for DrawPokerMessages.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DrawPokerMessagesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChdEcmF3UG9rZXJNZXNzYWdlcy5wcm90bxIec3luZXJneUJsdWUucHJvdG9i",
            "dWYuZHJhd1Bva2VyGg90aW1lc3RhbXAucHJvdG8aC0NhcmRzLnByb3RvIsIE",
            "CglHYW1lU3RhdGUSPQoMSW5pdGlhbENhcmRzGAEgAygLMicuc3luZXJneUJs",
            "dWUucHJvdG9idWYuY2FyZHMuUGxheWluZ0NhcmQSOwoKRmluYWxDYXJkcxgC",
            "IAMoCzInLnN5bmVyZ3lCbHVlLnByb3RvYnVmLmNhcmRzLlBsYXlpbmdDYXJk",
            "Ei0KCVRpbWVEZWFsdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3Rh",
            "bXASLQoJVGltZURyYXduGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVz",
            "dGFtcBJFChFJbml0aWFsRXZhbHVhdGlvbhgFIAEoCzIqLnN5bmVyZ3lCbHVl",
            "LnByb3RvYnVmLmRyYXdQb2tlci5FdmFsdWF0aW9uEkMKD0ZpbmFsRXZhbHVh",
            "dGlvbhgGIAEoCzIqLnN5bmVyZ3lCbHVlLnByb3RvYnVmLmRyYXdQb2tlci5F",
            "dmFsdWF0aW9uEkYKFUluaXRpYWxXaW5uaW5nUGF5bGluZRgHIAEoCzInLnN5",
            "bmVyZ3lCbHVlLnByb3RvYnVmLmRyYXdQb2tlci5QYXlsaW5lEkQKE0ZpbmFs",
            "V2lubmluZ1BheWxpbmUYCCABKAsyJy5zeW5lcmd5Qmx1ZS5wcm90b2J1Zi5k",
            "cmF3UG9rZXIuUGF5bGluZRIVCg1Jc0ZpbmFsUmVzdWx0GAkgASgIEhIKCldh",
            "Z2VySW5kZXgYCiABKAUSFgoOV2FnZXJJbkNyZWRpdHMYCyABKAUisgMKCkV2",
            "YWx1YXRpb24SGQoRRGlzdGluY3RSYW5rQ291bnQYASABKAUSIAoYRGlzdGlu",
            "Y3RSYW5rQ291bnRQcm9kdWN0GAIgASgFEjcKDE9yZGVyZWRSYW5rcxgDIAMo",
            "DjIhLnN5bmVyZ3lCbHVlLnByb3RvYnVmLmNhcmRzLkVSYW5rEj8KFEhpZ2hl",
            "c3REdXBsaWNhdGVSYW5rGAQgASgOMiEuc3luZXJneUJsdWUucHJvdG9idWYu",
            "Y2FyZHMuRVJhbmsSPwoOVW5vcmRlcmVkQ2FyZHMYBSADKAsyJy5zeW5lcmd5",
            "Qmx1ZS5wcm90b2J1Zi5jYXJkcy5QbGF5aW5nQ2FyZBIZChFOdW1iZXJPZldp",
            "bGRDYXJkcxgGIAEoBRITCgtGb3VyT2ZBS2luZBgHIAEoCBIUCgxUaHJlZU9m",
            "QUtpbmQYCCABKAgSDwoHVHdvUGFpchgJIAEoCBIMCgRQYWlyGAogASgIEhEK",
            "CUZ1bGxIb3VzZRgLIAEoCBINCgVGbHVzaBgMIAEoCBIQCghTdHJhaWdodBgN",
            "IAEoCBITCgtGaXZlT2ZBS2luZBgOIAEoCCLtAQoIUGF5dGFibGUSDgoGR2Ft",
            "ZUlkGAEgASgJEhIKClBheXRhYmxlSWQYAiABKAkSFAoMUGF5dGFibGVOYW1l",
            "GAMgASgJEg8KB1ZlcnNpb24YBCABKAkSCwoDUlRQGAUgASgJEhsKE051bWJl",
            "ck9mQ2FyZHNJbkRlY2sYBiABKAUSGwoTTnVtYmVyT2ZDYXJkc0luSGFuZBgH",
            "IAEoBRIUCgxIYXNXaWxkQ2FyZHMYCCABKAgSOQoIUGF5bGluZXMYCSADKAsy",
            "Jy5zeW5lcmd5Qmx1ZS5wcm90b2J1Zi5kcmF3UG9rZXIuUGF5bGluZSJfCgdQ",
            "YXlsaW5lEgoKAklkGAEgASgJEhoKEkVuZ2xpc2hEZXNjcmlwdGlvbhgCIAEo",
            "CRIYChBEaXNwbGF5U29ydEluZGV4GAMgASgFEhIKCldpbkFtb3VudHMYBCAD",
            "KAUiUwoQRHJhd1Bva2VyUmVxdWVzdBI/Cg5DYXJkc0Rpc2NhcmRlZBgBIAMo",
            "CzInLnN5bmVyZ3lCbHVlLnByb3RvYnVmLmNhcmRzLlBsYXlpbmdDYXJkIksK",
            "DFBheXRhYmxlTGlzdBI7CglQYXl0YWJsZXMYASADKAsyKC5zeW5lcmd5Qmx1",
            "ZS5wcm90b2J1Zi5kcmF3UG9rZXIuUGF5dGFibGViBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Protobuf.Cards.CardsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Protobuf.DrawPoker.GameState), global::Protobuf.DrawPoker.GameState.Parser, new[]{ "InitialCards", "FinalCards", "TimeDealt", "TimeDrawn", "InitialEvaluation", "FinalEvaluation", "InitialWinningPayline", "FinalWinningPayline", "IsFinalResult", "WagerIndex", "WagerInCredits" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protobuf.DrawPoker.Evaluation), global::Protobuf.DrawPoker.Evaluation.Parser, new[]{ "DistinctRankCount", "DistinctRankCountProduct", "OrderedRanks", "HighestDuplicateRank", "UnorderedCards", "NumberOfWildCards", "FourOfAKind", "ThreeOfAKind", "TwoPair", "Pair", "FullHouse", "Flush", "Straight", "FiveOfAKind" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protobuf.DrawPoker.Paytable), global::Protobuf.DrawPoker.Paytable.Parser, new[]{ "GameId", "PaytableId", "PaytableName", "Version", "RTP", "NumberOfCardsInDeck", "NumberOfCardsInHand", "HasWildCards", "Paylines" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protobuf.DrawPoker.Payline), global::Protobuf.DrawPoker.Payline.Parser, new[]{ "Id", "EnglishDescription", "DisplaySortIndex", "WinAmounts" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protobuf.DrawPoker.DrawPokerRequest), global::Protobuf.DrawPoker.DrawPokerRequest.Parser, new[]{ "CardsDiscarded" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protobuf.DrawPoker.PaytableList), global::Protobuf.DrawPoker.PaytableList.Parser, new[]{ "Paytables" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class GameState : pb::IMessage<GameState> {
    private static readonly pb::MessageParser<GameState> _parser = new pb::MessageParser<GameState>(() => new GameState());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GameState> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protobuf.DrawPoker.DrawPokerMessagesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GameState() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GameState(GameState other) : this() {
      initialCards_ = other.initialCards_.Clone();
      finalCards_ = other.finalCards_.Clone();
      TimeDealt = other.timeDealt_ != null ? other.TimeDealt.Clone() : null;
      TimeDrawn = other.timeDrawn_ != null ? other.TimeDrawn.Clone() : null;
      InitialEvaluation = other.initialEvaluation_ != null ? other.InitialEvaluation.Clone() : null;
      FinalEvaluation = other.finalEvaluation_ != null ? other.FinalEvaluation.Clone() : null;
      InitialWinningPayline = other.initialWinningPayline_ != null ? other.InitialWinningPayline.Clone() : null;
      FinalWinningPayline = other.finalWinningPayline_ != null ? other.FinalWinningPayline.Clone() : null;
      isFinalResult_ = other.isFinalResult_;
      wagerIndex_ = other.wagerIndex_;
      wagerInCredits_ = other.wagerInCredits_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GameState Clone() {
      return new GameState(this);
    }

    /// <summary>Field number for the "InitialCards" field.</summary>
    public const int InitialCardsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Protobuf.Cards.PlayingCard> _repeated_initialCards_codec
        = pb::FieldCodec.ForMessage(10, global::Protobuf.Cards.PlayingCard.Parser);
    private readonly pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> initialCards_ = new pbc::RepeatedField<global::Protobuf.Cards.PlayingCard>();
    /// <summary>
    /// The cards that were dealt at the beginning of the game. Should always be exactly 5 of
    /// them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> InitialCards {
      get { return initialCards_; }
    }

    /// <summary>Field number for the "FinalCards" field.</summary>
    public const int FinalCardsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Protobuf.Cards.PlayingCard> _repeated_finalCards_codec
        = pb::FieldCodec.ForMessage(18, global::Protobuf.Cards.PlayingCard.Parser);
    private readonly pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> finalCards_ = new pbc::RepeatedField<global::Protobuf.Cards.PlayingCard>();
    /// <summary>
    /// The cards resulting from the player's choice- Ie the cards that the player HELD plus the
    /// cards which replaced the cards the player DISCARDED. Should always be exactly 5 of them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> FinalCards {
      get { return finalCards_; }
    }

    /// <summary>Field number for the "TimeDealt" field.</summary>
    public const int TimeDealtFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp timeDealt_;
    /// <summary>
    /// The timestamp of when the cards were dealt (RNG first used to generate cards)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp TimeDealt {
      get { return timeDealt_; }
      set {
        timeDealt_ = value;
      }
    }

    /// <summary>Field number for the "TimeDrawn" field.</summary>
    public const int TimeDrawnFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp timeDrawn_;
    /// <summary>
    /// The time that the cards were generated to replace those cards discarded by the player.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp TimeDrawn {
      get { return timeDrawn_; }
      set {
        timeDrawn_ = value;
      }
    }

    /// <summary>Field number for the "InitialEvaluation" field.</summary>
    public const int InitialEvaluationFieldNumber = 5;
    private global::Protobuf.DrawPoker.Evaluation initialEvaluation_;
    /// <summary>
    /// If set, this represents how the initial cards were evaluated given the paytable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protobuf.DrawPoker.Evaluation InitialEvaluation {
      get { return initialEvaluation_; }
      set {
        initialEvaluation_ = value;
      }
    }

    /// <summary>Field number for the "FinalEvaluation" field.</summary>
    public const int FinalEvaluationFieldNumber = 6;
    private global::Protobuf.DrawPoker.Evaluation finalEvaluation_;
    /// <summary>
    /// If set, this represents how the final cards were evaluated given the paytable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protobuf.DrawPoker.Evaluation FinalEvaluation {
      get { return finalEvaluation_; }
      set {
        finalEvaluation_ = value;
      }
    }

    /// <summary>Field number for the "InitialWinningPayline" field.</summary>
    public const int InitialWinningPaylineFieldNumber = 7;
    private global::Protobuf.DrawPoker.Payline initialWinningPayline_;
    /// <summary>
    /// If the "InitialEvaluation" resulted in a winning payline, this is set to that payline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protobuf.DrawPoker.Payline InitialWinningPayline {
      get { return initialWinningPayline_; }
      set {
        initialWinningPayline_ = value;
      }
    }

    /// <summary>Field number for the "FinalWinningPayline" field.</summary>
    public const int FinalWinningPaylineFieldNumber = 8;
    private global::Protobuf.DrawPoker.Payline finalWinningPayline_;
    /// <summary>
    /// If the "FinalEvaluation" resulted in a winning payline, this is set to that payline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protobuf.DrawPoker.Payline FinalWinningPayline {
      get { return finalWinningPayline_; }
      set {
        finalWinningPayline_ = value;
      }
    }

    /// <summary>Field number for the "IsFinalResult" field.</summary>
    public const int IsFinalResultFieldNumber = 9;
    private bool isFinalResult_;
    /// <summary>
    /// If TRUE, then all properties of this object should be set AND the game is considered
    /// over.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFinalResult {
      get { return isFinalResult_; }
      set {
        isFinalResult_ = value;
      }
    }

    /// <summary>Field number for the "WagerIndex" field.</summary>
    public const int WagerIndexFieldNumber = 10;
    private int wagerIndex_;
    /// <summary>
    /// The index of the wager into the enabled wager amounts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int WagerIndex {
      get { return wagerIndex_; }
      set {
        wagerIndex_ = value;
      }
    }

    /// <summary>Field number for the "WagerInCredits" field.</summary>
    public const int WagerInCreditsFieldNumber = 11;
    private int wagerInCredits_;
    /// <summary>
    /// The amount of the wager, in credits
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int WagerInCredits {
      get { return wagerInCredits_; }
      set {
        wagerInCredits_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GameState);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GameState other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!initialCards_.Equals(other.initialCards_)) return false;
      if(!finalCards_.Equals(other.finalCards_)) return false;
      if (!object.Equals(TimeDealt, other.TimeDealt)) return false;
      if (!object.Equals(TimeDrawn, other.TimeDrawn)) return false;
      if (!object.Equals(InitialEvaluation, other.InitialEvaluation)) return false;
      if (!object.Equals(FinalEvaluation, other.FinalEvaluation)) return false;
      if (!object.Equals(InitialWinningPayline, other.InitialWinningPayline)) return false;
      if (!object.Equals(FinalWinningPayline, other.FinalWinningPayline)) return false;
      if (IsFinalResult != other.IsFinalResult) return false;
      if (WagerIndex != other.WagerIndex) return false;
      if (WagerInCredits != other.WagerInCredits) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= initialCards_.GetHashCode();
      hash ^= finalCards_.GetHashCode();
      if (timeDealt_ != null) hash ^= TimeDealt.GetHashCode();
      if (timeDrawn_ != null) hash ^= TimeDrawn.GetHashCode();
      if (initialEvaluation_ != null) hash ^= InitialEvaluation.GetHashCode();
      if (finalEvaluation_ != null) hash ^= FinalEvaluation.GetHashCode();
      if (initialWinningPayline_ != null) hash ^= InitialWinningPayline.GetHashCode();
      if (finalWinningPayline_ != null) hash ^= FinalWinningPayline.GetHashCode();
      if (IsFinalResult != false) hash ^= IsFinalResult.GetHashCode();
      if (WagerIndex != 0) hash ^= WagerIndex.GetHashCode();
      if (WagerInCredits != 0) hash ^= WagerInCredits.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      initialCards_.WriteTo(output, _repeated_initialCards_codec);
      finalCards_.WriteTo(output, _repeated_finalCards_codec);
      if (timeDealt_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TimeDealt);
      }
      if (timeDrawn_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(TimeDrawn);
      }
      if (initialEvaluation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(InitialEvaluation);
      }
      if (finalEvaluation_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FinalEvaluation);
      }
      if (initialWinningPayline_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(InitialWinningPayline);
      }
      if (finalWinningPayline_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(FinalWinningPayline);
      }
      if (IsFinalResult != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsFinalResult);
      }
      if (WagerIndex != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(WagerIndex);
      }
      if (WagerInCredits != 0) {
        output.WriteRawTag(88);
        output.WriteInt32(WagerInCredits);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += initialCards_.CalculateSize(_repeated_initialCards_codec);
      size += finalCards_.CalculateSize(_repeated_finalCards_codec);
      if (timeDealt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeDealt);
      }
      if (timeDrawn_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeDrawn);
      }
      if (initialEvaluation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialEvaluation);
      }
      if (finalEvaluation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FinalEvaluation);
      }
      if (initialWinningPayline_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialWinningPayline);
      }
      if (finalWinningPayline_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FinalWinningPayline);
      }
      if (IsFinalResult != false) {
        size += 1 + 1;
      }
      if (WagerIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(WagerIndex);
      }
      if (WagerInCredits != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(WagerInCredits);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GameState other) {
      if (other == null) {
        return;
      }
      initialCards_.Add(other.initialCards_);
      finalCards_.Add(other.finalCards_);
      if (other.timeDealt_ != null) {
        if (timeDealt_ == null) {
          timeDealt_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        TimeDealt.MergeFrom(other.TimeDealt);
      }
      if (other.timeDrawn_ != null) {
        if (timeDrawn_ == null) {
          timeDrawn_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        TimeDrawn.MergeFrom(other.TimeDrawn);
      }
      if (other.initialEvaluation_ != null) {
        if (initialEvaluation_ == null) {
          initialEvaluation_ = new global::Protobuf.DrawPoker.Evaluation();
        }
        InitialEvaluation.MergeFrom(other.InitialEvaluation);
      }
      if (other.finalEvaluation_ != null) {
        if (finalEvaluation_ == null) {
          finalEvaluation_ = new global::Protobuf.DrawPoker.Evaluation();
        }
        FinalEvaluation.MergeFrom(other.FinalEvaluation);
      }
      if (other.initialWinningPayline_ != null) {
        if (initialWinningPayline_ == null) {
          initialWinningPayline_ = new global::Protobuf.DrawPoker.Payline();
        }
        InitialWinningPayline.MergeFrom(other.InitialWinningPayline);
      }
      if (other.finalWinningPayline_ != null) {
        if (finalWinningPayline_ == null) {
          finalWinningPayline_ = new global::Protobuf.DrawPoker.Payline();
        }
        FinalWinningPayline.MergeFrom(other.FinalWinningPayline);
      }
      if (other.IsFinalResult != false) {
        IsFinalResult = other.IsFinalResult;
      }
      if (other.WagerIndex != 0) {
        WagerIndex = other.WagerIndex;
      }
      if (other.WagerInCredits != 0) {
        WagerInCredits = other.WagerInCredits;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            initialCards_.AddEntriesFrom(input, _repeated_initialCards_codec);
            break;
          }
          case 18: {
            finalCards_.AddEntriesFrom(input, _repeated_finalCards_codec);
            break;
          }
          case 26: {
            if (timeDealt_ == null) {
              timeDealt_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(timeDealt_);
            break;
          }
          case 34: {
            if (timeDrawn_ == null) {
              timeDrawn_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(timeDrawn_);
            break;
          }
          case 42: {
            if (initialEvaluation_ == null) {
              initialEvaluation_ = new global::Protobuf.DrawPoker.Evaluation();
            }
            input.ReadMessage(initialEvaluation_);
            break;
          }
          case 50: {
            if (finalEvaluation_ == null) {
              finalEvaluation_ = new global::Protobuf.DrawPoker.Evaluation();
            }
            input.ReadMessage(finalEvaluation_);
            break;
          }
          case 58: {
            if (initialWinningPayline_ == null) {
              initialWinningPayline_ = new global::Protobuf.DrawPoker.Payline();
            }
            input.ReadMessage(initialWinningPayline_);
            break;
          }
          case 66: {
            if (finalWinningPayline_ == null) {
              finalWinningPayline_ = new global::Protobuf.DrawPoker.Payline();
            }
            input.ReadMessage(finalWinningPayline_);
            break;
          }
          case 72: {
            IsFinalResult = input.ReadBool();
            break;
          }
          case 80: {
            WagerIndex = input.ReadInt32();
            break;
          }
          case 88: {
            WagerInCredits = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The results of a poker hand evaluation- This is in terms of extremely basic poker
  /// information. Specifically, things like "straight-flush" or "4-Aces" are not detected, as they
  /// are completely derivative of the data found here. Full Houses are only identified because
  /// they are trivial to detect (a single "else" statement with an assignment to the bool)
  /// </summary>
  public sealed partial class Evaluation : pb::IMessage<Evaluation> {
    private static readonly pb::MessageParser<Evaluation> _parser = new pb::MessageParser<Evaluation>(() => new Evaluation());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Evaluation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protobuf.DrawPoker.DrawPokerMessagesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Evaluation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Evaluation(Evaluation other) : this() {
      distinctRankCount_ = other.distinctRankCount_;
      distinctRankCountProduct_ = other.distinctRankCountProduct_;
      orderedRanks_ = other.orderedRanks_.Clone();
      highestDuplicateRank_ = other.highestDuplicateRank_;
      unorderedCards_ = other.unorderedCards_.Clone();
      numberOfWildCards_ = other.numberOfWildCards_;
      fourOfAKind_ = other.fourOfAKind_;
      threeOfAKind_ = other.threeOfAKind_;
      twoPair_ = other.twoPair_;
      pair_ = other.pair_;
      fullHouse_ = other.fullHouse_;
      flush_ = other.flush_;
      straight_ = other.straight_;
      fiveOfAKind_ = other.fiveOfAKind_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Evaluation Clone() {
      return new Evaluation(this);
    }

    /// <summary>Field number for the "DistinctRankCount" field.</summary>
    public const int DistinctRankCountFieldNumber = 1;
    private int distinctRankCount_;
    /// <summary>
    /// This represents the number of different Ranks found in a poker hand.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DistinctRankCount {
      get { return distinctRankCount_; }
      set {
        distinctRankCount_ = value;
      }
    }

    /// <summary>Field number for the "DistinctRankCountProduct" field.</summary>
    public const int DistinctRankCountProductFieldNumber = 2;
    private int distinctRankCountProduct_;
    /// <summary>
    /// This is calculated as the product of the counts of different ranks in a poker hand. It is
    /// used in conjunction with DistinctRankCount to determine exactly which type of "of-a-kind"
    /// hand is present. This relies on observations in prime factorization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DistinctRankCountProduct {
      get { return distinctRankCountProduct_; }
      set {
        distinctRankCountProduct_ = value;
      }
    }

    /// <summary>Field number for the "OrderedRanks" field.</summary>
    public const int OrderedRanksFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Protobuf.Cards.ERank> _repeated_orderedRanks_codec
        = pb::FieldCodec.ForEnum(26, x => (int) x, x => (global::Protobuf.Cards.ERank) x);
    private readonly pbc::RepeatedField<global::Protobuf.Cards.ERank> orderedRanks_ = new pbc::RepeatedField<global::Protobuf.Cards.ERank>();
    /// <summary>
    /// The Ranks found in the hand, ordered from 2 through Ace
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.Cards.ERank> OrderedRanks {
      get { return orderedRanks_; }
    }

    /// <summary>Field number for the "HighestDuplicateRank" field.</summary>
    public const int HighestDuplicateRankFieldNumber = 4;
    private global::Protobuf.Cards.ERank highestDuplicateRank_ = 0;
    /// <summary>
    /// The highest rank with a plurality of cards found in the hand
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protobuf.Cards.ERank HighestDuplicateRank {
      get { return highestDuplicateRank_; }
      set {
        highestDuplicateRank_ = value;
      }
    }

    /// <summary>Field number for the "UnorderedCards" field.</summary>
    public const int UnorderedCardsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Protobuf.Cards.PlayingCard> _repeated_unorderedCards_codec
        = pb::FieldCodec.ForMessage(42, global::Protobuf.Cards.PlayingCard.Parser);
    private readonly pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> unorderedCards_ = new pbc::RepeatedField<global::Protobuf.Cards.PlayingCard>();
    /// <summary>
    /// The cards used to create this evaluation in the same order they were presented to the
    /// evaluator
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> UnorderedCards {
      get { return unorderedCards_; }
    }

    /// <summary>Field number for the "NumberOfWildCards" field.</summary>
    public const int NumberOfWildCardsFieldNumber = 6;
    private int numberOfWildCards_;
    /// <summary>
    /// The number of wild cards used to make the hand.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumberOfWildCards {
      get { return numberOfWildCards_; }
      set {
        numberOfWildCards_ = value;
      }
    }

    /// <summary>Field number for the "FourOfAKind" field.</summary>
    public const int FourOfAKindFieldNumber = 7;
    private bool fourOfAKind_;
    /// <summary>
    /// A Four of a Kind
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FourOfAKind {
      get { return fourOfAKind_; }
      set {
        fourOfAKind_ = value;
      }
    }

    /// <summary>Field number for the "ThreeOfAKind" field.</summary>
    public const int ThreeOfAKindFieldNumber = 8;
    private bool threeOfAKind_;
    /// <summary>
    /// A Three of a Kind but NOT FourOfAKind and NOT FullHouse
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ThreeOfAKind {
      get { return threeOfAKind_; }
      set {
        threeOfAKind_ = value;
      }
    }

    /// <summary>Field number for the "TwoPair" field.</summary>
    public const int TwoPairFieldNumber = 9;
    private bool twoPair_;
    /// <summary>
    /// Two Different Pairs but NOT a FullHouse
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool TwoPair {
      get { return twoPair_; }
      set {
        twoPair_ = value;
      }
    }

    /// <summary>Field number for the "Pair" field.</summary>
    public const int PairFieldNumber = 10;
    private bool pair_;
    /// <summary>
    /// A single Pair, but no TwoPair, ThreeOfAKind, FourOfAKind, or FullHouse
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Pair {
      get { return pair_; }
      set {
        pair_ = value;
      }
    }

    /// <summary>Field number for the "FullHouse" field.</summary>
    public const int FullHouseFieldNumber = 11;
    private bool fullHouse_;
    /// <summary>
    /// A ThreeOfAKind of one Rank and a Pair of another Rank
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FullHouse {
      get { return fullHouse_; }
      set {
        fullHouse_ = value;
      }
    }

    /// <summary>Field number for the "Flush" field.</summary>
    public const int FlushFieldNumber = 12;
    private bool flush_;
    /// <summary>
    /// All the same suit
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Flush {
      get { return flush_; }
      set {
        flush_ = value;
      }
    }

    /// <summary>Field number for the "Straight" field.</summary>
    public const int StraightFieldNumber = 13;
    private bool straight_;
    /// <summary>
    /// All cards consecutive OR A-2-3-4-5
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Straight {
      get { return straight_; }
      set {
        straight_ = value;
      }
    }

    /// <summary>Field number for the "FiveOfAKind" field.</summary>
    public const int FiveOfAKindFieldNumber = 14;
    private bool fiveOfAKind_;
    /// <summary>
    /// All ranks equal (need wild cards or multiple decks)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FiveOfAKind {
      get { return fiveOfAKind_; }
      set {
        fiveOfAKind_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Evaluation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Evaluation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DistinctRankCount != other.DistinctRankCount) return false;
      if (DistinctRankCountProduct != other.DistinctRankCountProduct) return false;
      if(!orderedRanks_.Equals(other.orderedRanks_)) return false;
      if (HighestDuplicateRank != other.HighestDuplicateRank) return false;
      if(!unorderedCards_.Equals(other.unorderedCards_)) return false;
      if (NumberOfWildCards != other.NumberOfWildCards) return false;
      if (FourOfAKind != other.FourOfAKind) return false;
      if (ThreeOfAKind != other.ThreeOfAKind) return false;
      if (TwoPair != other.TwoPair) return false;
      if (Pair != other.Pair) return false;
      if (FullHouse != other.FullHouse) return false;
      if (Flush != other.Flush) return false;
      if (Straight != other.Straight) return false;
      if (FiveOfAKind != other.FiveOfAKind) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DistinctRankCount != 0) hash ^= DistinctRankCount.GetHashCode();
      if (DistinctRankCountProduct != 0) hash ^= DistinctRankCountProduct.GetHashCode();
      hash ^= orderedRanks_.GetHashCode();
      if (HighestDuplicateRank != 0) hash ^= HighestDuplicateRank.GetHashCode();
      hash ^= unorderedCards_.GetHashCode();
      if (NumberOfWildCards != 0) hash ^= NumberOfWildCards.GetHashCode();
      if (FourOfAKind != false) hash ^= FourOfAKind.GetHashCode();
      if (ThreeOfAKind != false) hash ^= ThreeOfAKind.GetHashCode();
      if (TwoPair != false) hash ^= TwoPair.GetHashCode();
      if (Pair != false) hash ^= Pair.GetHashCode();
      if (FullHouse != false) hash ^= FullHouse.GetHashCode();
      if (Flush != false) hash ^= Flush.GetHashCode();
      if (Straight != false) hash ^= Straight.GetHashCode();
      if (FiveOfAKind != false) hash ^= FiveOfAKind.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (DistinctRankCount != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(DistinctRankCount);
      }
      if (DistinctRankCountProduct != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(DistinctRankCountProduct);
      }
      orderedRanks_.WriteTo(output, _repeated_orderedRanks_codec);
      if (HighestDuplicateRank != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) HighestDuplicateRank);
      }
      unorderedCards_.WriteTo(output, _repeated_unorderedCards_codec);
      if (NumberOfWildCards != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(NumberOfWildCards);
      }
      if (FourOfAKind != false) {
        output.WriteRawTag(56);
        output.WriteBool(FourOfAKind);
      }
      if (ThreeOfAKind != false) {
        output.WriteRawTag(64);
        output.WriteBool(ThreeOfAKind);
      }
      if (TwoPair != false) {
        output.WriteRawTag(72);
        output.WriteBool(TwoPair);
      }
      if (Pair != false) {
        output.WriteRawTag(80);
        output.WriteBool(Pair);
      }
      if (FullHouse != false) {
        output.WriteRawTag(88);
        output.WriteBool(FullHouse);
      }
      if (Flush != false) {
        output.WriteRawTag(96);
        output.WriteBool(Flush);
      }
      if (Straight != false) {
        output.WriteRawTag(104);
        output.WriteBool(Straight);
      }
      if (FiveOfAKind != false) {
        output.WriteRawTag(112);
        output.WriteBool(FiveOfAKind);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DistinctRankCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DistinctRankCount);
      }
      if (DistinctRankCountProduct != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DistinctRankCountProduct);
      }
      size += orderedRanks_.CalculateSize(_repeated_orderedRanks_codec);
      if (HighestDuplicateRank != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HighestDuplicateRank);
      }
      size += unorderedCards_.CalculateSize(_repeated_unorderedCards_codec);
      if (NumberOfWildCards != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumberOfWildCards);
      }
      if (FourOfAKind != false) {
        size += 1 + 1;
      }
      if (ThreeOfAKind != false) {
        size += 1 + 1;
      }
      if (TwoPair != false) {
        size += 1 + 1;
      }
      if (Pair != false) {
        size += 1 + 1;
      }
      if (FullHouse != false) {
        size += 1 + 1;
      }
      if (Flush != false) {
        size += 1 + 1;
      }
      if (Straight != false) {
        size += 1 + 1;
      }
      if (FiveOfAKind != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Evaluation other) {
      if (other == null) {
        return;
      }
      if (other.DistinctRankCount != 0) {
        DistinctRankCount = other.DistinctRankCount;
      }
      if (other.DistinctRankCountProduct != 0) {
        DistinctRankCountProduct = other.DistinctRankCountProduct;
      }
      orderedRanks_.Add(other.orderedRanks_);
      if (other.HighestDuplicateRank != 0) {
        HighestDuplicateRank = other.HighestDuplicateRank;
      }
      unorderedCards_.Add(other.unorderedCards_);
      if (other.NumberOfWildCards != 0) {
        NumberOfWildCards = other.NumberOfWildCards;
      }
      if (other.FourOfAKind != false) {
        FourOfAKind = other.FourOfAKind;
      }
      if (other.ThreeOfAKind != false) {
        ThreeOfAKind = other.ThreeOfAKind;
      }
      if (other.TwoPair != false) {
        TwoPair = other.TwoPair;
      }
      if (other.Pair != false) {
        Pair = other.Pair;
      }
      if (other.FullHouse != false) {
        FullHouse = other.FullHouse;
      }
      if (other.Flush != false) {
        Flush = other.Flush;
      }
      if (other.Straight != false) {
        Straight = other.Straight;
      }
      if (other.FiveOfAKind != false) {
        FiveOfAKind = other.FiveOfAKind;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            DistinctRankCount = input.ReadInt32();
            break;
          }
          case 16: {
            DistinctRankCountProduct = input.ReadInt32();
            break;
          }
          case 26:
          case 24: {
            orderedRanks_.AddEntriesFrom(input, _repeated_orderedRanks_codec);
            break;
          }
          case 32: {
            highestDuplicateRank_ = (global::Protobuf.Cards.ERank) input.ReadEnum();
            break;
          }
          case 42: {
            unorderedCards_.AddEntriesFrom(input, _repeated_unorderedCards_codec);
            break;
          }
          case 48: {
            NumberOfWildCards = input.ReadInt32();
            break;
          }
          case 56: {
            FourOfAKind = input.ReadBool();
            break;
          }
          case 64: {
            ThreeOfAKind = input.ReadBool();
            break;
          }
          case 72: {
            TwoPair = input.ReadBool();
            break;
          }
          case 80: {
            Pair = input.ReadBool();
            break;
          }
          case 88: {
            FullHouse = input.ReadBool();
            break;
          }
          case 96: {
            Flush = input.ReadBool();
            break;
          }
          case 104: {
            Straight = input.ReadBool();
            break;
          }
          case 112: {
            FiveOfAKind = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A collection of PayLines to be used when determining how to pay for a hand
  /// </summary>
  public sealed partial class Paytable : pb::IMessage<Paytable> {
    private static readonly pb::MessageParser<Paytable> _parser = new pb::MessageParser<Paytable>(() => new Paytable());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Paytable> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protobuf.DrawPoker.DrawPokerMessagesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Paytable() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Paytable(Paytable other) : this() {
      gameId_ = other.gameId_;
      paytableId_ = other.paytableId_;
      paytableName_ = other.paytableName_;
      version_ = other.version_;
      rTP_ = other.rTP_;
      numberOfCardsInDeck_ = other.numberOfCardsInDeck_;
      numberOfCardsInHand_ = other.numberOfCardsInHand_;
      hasWildCards_ = other.hasWildCards_;
      paylines_ = other.paylines_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Paytable Clone() {
      return new Paytable(this);
    }

    /// <summary>Field number for the "GameId" field.</summary>
    public const int GameIdFieldNumber = 1;
    private string gameId_ = "";
    /// <summary>
    /// The GameID that this paytable belongs to
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GameId {
      get { return gameId_; }
      set {
        gameId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "PaytableId" field.</summary>
    public const int PaytableIdFieldNumber = 2;
    private string paytableId_ = "";
    /// <summary>
    /// A Unique ID for the specific payout schedule (classically called a "paytable")
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PaytableId {
      get { return paytableId_; }
      set {
        paytableId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "PaytableName" field.</summary>
    public const int PaytableNameFieldNumber = 3;
    private string paytableName_ = "";
    /// <summary>
    /// An English-description/Name for the Payout schedule (should be exclusive of RTP info)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PaytableName {
      get { return paytableName_; }
      set {
        paytableName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "Version" field.</summary>
    public const int VersionFieldNumber = 4;
    private string version_ = "";
    /// <summary>
    /// a version number which gets changed when the underlying logic or rules don't change, but
    /// the source code does.4
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "RTP" field.</summary>
    public const int RTPFieldNumber = 5;
    private string rTP_ = "";
    /// <summary>
    /// The RTP for this payout schedule. Should only be displayed on the attendant menu.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RTP {
      get { return rTP_; }
      set {
        rTP_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "NumberOfCardsInDeck" field.</summary>
    public const int NumberOfCardsInDeckFieldNumber = 6;
    private int numberOfCardsInDeck_;
    /// <summary>
    /// How many cards are in a deck for this poker variant
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumberOfCardsInDeck {
      get { return numberOfCardsInDeck_; }
      set {
        numberOfCardsInDeck_ = value;
      }
    }

    /// <summary>Field number for the "NumberOfCardsInHand" field.</summary>
    public const int NumberOfCardsInHandFieldNumber = 7;
    private int numberOfCardsInHand_;
    /// <summary>
    /// The number of cards in a hand. Typically 5 or 7.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumberOfCardsInHand {
      get { return numberOfCardsInHand_; }
      set {
        numberOfCardsInHand_ = value;
      }
    }

    /// <summary>Field number for the "HasWildCards" field.</summary>
    public const int HasWildCardsFieldNumber = 8;
    private bool hasWildCards_;
    /// <summary>
    /// Describes if the deck/evaluations consider Wild Cards.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWildCards {
      get { return hasWildCards_; }
      set {
        hasWildCards_ = value;
      }
    }

    /// <summary>Field number for the "Paylines" field.</summary>
    public const int PaylinesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Protobuf.DrawPoker.Payline> _repeated_paylines_codec
        = pb::FieldCodec.ForMessage(74, global::Protobuf.DrawPoker.Payline.Parser);
    private readonly pbc::RepeatedField<global::Protobuf.DrawPoker.Payline> paylines_ = new pbc::RepeatedField<global::Protobuf.DrawPoker.Payline>();
    /// <summary>
    /// The PayLines that are assocated with this paytable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.DrawPoker.Payline> Paylines {
      get { return paylines_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Paytable);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Paytable other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GameId != other.GameId) return false;
      if (PaytableId != other.PaytableId) return false;
      if (PaytableName != other.PaytableName) return false;
      if (Version != other.Version) return false;
      if (RTP != other.RTP) return false;
      if (NumberOfCardsInDeck != other.NumberOfCardsInDeck) return false;
      if (NumberOfCardsInHand != other.NumberOfCardsInHand) return false;
      if (HasWildCards != other.HasWildCards) return false;
      if(!paylines_.Equals(other.paylines_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (GameId.Length != 0) hash ^= GameId.GetHashCode();
      if (PaytableId.Length != 0) hash ^= PaytableId.GetHashCode();
      if (PaytableName.Length != 0) hash ^= PaytableName.GetHashCode();
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      if (RTP.Length != 0) hash ^= RTP.GetHashCode();
      if (NumberOfCardsInDeck != 0) hash ^= NumberOfCardsInDeck.GetHashCode();
      if (NumberOfCardsInHand != 0) hash ^= NumberOfCardsInHand.GetHashCode();
      if (HasWildCards != false) hash ^= HasWildCards.GetHashCode();
      hash ^= paylines_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (GameId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(GameId);
      }
      if (PaytableId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PaytableId);
      }
      if (PaytableName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(PaytableName);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Version);
      }
      if (RTP.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(RTP);
      }
      if (NumberOfCardsInDeck != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(NumberOfCardsInDeck);
      }
      if (NumberOfCardsInHand != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(NumberOfCardsInHand);
      }
      if (HasWildCards != false) {
        output.WriteRawTag(64);
        output.WriteBool(HasWildCards);
      }
      paylines_.WriteTo(output, _repeated_paylines_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (GameId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GameId);
      }
      if (PaytableId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PaytableId);
      }
      if (PaytableName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PaytableName);
      }
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (RTP.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RTP);
      }
      if (NumberOfCardsInDeck != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumberOfCardsInDeck);
      }
      if (NumberOfCardsInHand != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumberOfCardsInHand);
      }
      if (HasWildCards != false) {
        size += 1 + 1;
      }
      size += paylines_.CalculateSize(_repeated_paylines_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Paytable other) {
      if (other == null) {
        return;
      }
      if (other.GameId.Length != 0) {
        GameId = other.GameId;
      }
      if (other.PaytableId.Length != 0) {
        PaytableId = other.PaytableId;
      }
      if (other.PaytableName.Length != 0) {
        PaytableName = other.PaytableName;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      if (other.RTP.Length != 0) {
        RTP = other.RTP;
      }
      if (other.NumberOfCardsInDeck != 0) {
        NumberOfCardsInDeck = other.NumberOfCardsInDeck;
      }
      if (other.NumberOfCardsInHand != 0) {
        NumberOfCardsInHand = other.NumberOfCardsInHand;
      }
      if (other.HasWildCards != false) {
        HasWildCards = other.HasWildCards;
      }
      paylines_.Add(other.paylines_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            GameId = input.ReadString();
            break;
          }
          case 18: {
            PaytableId = input.ReadString();
            break;
          }
          case 26: {
            PaytableName = input.ReadString();
            break;
          }
          case 34: {
            Version = input.ReadString();
            break;
          }
          case 42: {
            RTP = input.ReadString();
            break;
          }
          case 48: {
            NumberOfCardsInDeck = input.ReadInt32();
            break;
          }
          case 56: {
            NumberOfCardsInHand = input.ReadInt32();
            break;
          }
          case 64: {
            HasWildCards = input.ReadBool();
            break;
          }
          case 74: {
            paylines_.AddEntriesFrom(input, _repeated_paylines_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Data about a single opportunity for a hand to pay something.
  /// </summary>
  public sealed partial class Payline : pb::IMessage<Payline> {
    private static readonly pb::MessageParser<Payline> _parser = new pb::MessageParser<Payline>(() => new Payline());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Payline> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protobuf.DrawPoker.DrawPokerMessagesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Payline() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Payline(Payline other) : this() {
      id_ = other.id_;
      englishDescription_ = other.englishDescription_;
      displaySortIndex_ = other.displaySortIndex_;
      winAmounts_ = other.winAmounts_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Payline Clone() {
      return new Payline(this);
    }

    /// <summary>Field number for the "Id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    /// A unique ID for the payline- Must correspond to an Evaluator static method that has been
    /// decorated with a matching APaylineEvaluatorAttribute. This is case-Insensitive and all
    /// spaces are removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "EnglishDescription" field.</summary>
    public const int EnglishDescriptionFieldNumber = 2;
    private string englishDescription_ = "";
    /// <summary>
    /// A concise English language description.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string EnglishDescription {
      get { return englishDescription_; }
      set {
        englishDescription_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "DisplaySortIndex" field.</summary>
    public const int DisplaySortIndexFieldNumber = 3;
    private int displaySortIndex_;
    /// <summary>
    /// Higher numbers should be displayed farther towards the TOP of the paytable display.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DisplaySortIndex {
      get { return displaySortIndex_; }
      set {
        displaySortIndex_ = value;
      }
    }

    /// <summary>Field number for the "WinAmounts" field.</summary>
    public const int WinAmountsFieldNumber = 4;
    private static readonly pb::FieldCodec<int> _repeated_winAmounts_codec
        = pb::FieldCodec.ForInt32(34);
    private readonly pbc::RepeatedField<int> winAmounts_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// How much is paid for a hand that is identified as matching this payline. If there's only
    /// one entry, then the wager is simply multiplied by that single entry value. If there are
    /// multiple entries, then the index of the wager in the "enabledWagers" list is used to
    /// lookup an entry in this list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> WinAmounts {
      get { return winAmounts_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Payline);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Payline other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (EnglishDescription != other.EnglishDescription) return false;
      if (DisplaySortIndex != other.DisplaySortIndex) return false;
      if(!winAmounts_.Equals(other.winAmounts_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (EnglishDescription.Length != 0) hash ^= EnglishDescription.GetHashCode();
      if (DisplaySortIndex != 0) hash ^= DisplaySortIndex.GetHashCode();
      hash ^= winAmounts_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (EnglishDescription.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(EnglishDescription);
      }
      if (DisplaySortIndex != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(DisplaySortIndex);
      }
      winAmounts_.WriteTo(output, _repeated_winAmounts_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (EnglishDescription.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EnglishDescription);
      }
      if (DisplaySortIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DisplaySortIndex);
      }
      size += winAmounts_.CalculateSize(_repeated_winAmounts_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Payline other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.EnglishDescription.Length != 0) {
        EnglishDescription = other.EnglishDescription;
      }
      if (other.DisplaySortIndex != 0) {
        DisplaySortIndex = other.DisplaySortIndex;
      }
      winAmounts_.Add(other.winAmounts_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            EnglishDescription = input.ReadString();
            break;
          }
          case 24: {
            DisplaySortIndex = input.ReadInt32();
            break;
          }
          case 34:
          case 32: {
            winAmounts_.AddEntriesFrom(input, _repeated_winAmounts_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class DrawPokerRequest : pb::IMessage<DrawPokerRequest> {
    private static readonly pb::MessageParser<DrawPokerRequest> _parser = new pb::MessageParser<DrawPokerRequest>(() => new DrawPokerRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DrawPokerRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protobuf.DrawPoker.DrawPokerMessagesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DrawPokerRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DrawPokerRequest(DrawPokerRequest other) : this() {
      cardsDiscarded_ = other.cardsDiscarded_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DrawPokerRequest Clone() {
      return new DrawPokerRequest(this);
    }

    /// <summary>Field number for the "CardsDiscarded" field.</summary>
    public const int CardsDiscardedFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Protobuf.Cards.PlayingCard> _repeated_cardsDiscarded_codec
        = pb::FieldCodec.ForMessage(10, global::Protobuf.Cards.PlayingCard.Parser);
    private readonly pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> cardsDiscarded_ = new pbc::RepeatedField<global::Protobuf.Cards.PlayingCard>();
    /// <summary>
    /// The cards that the player chose to discard. These cards will be replaced with new cards
    /// in the second state of this game. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.Cards.PlayingCard> CardsDiscarded {
      get { return cardsDiscarded_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DrawPokerRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DrawPokerRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!cardsDiscarded_.Equals(other.cardsDiscarded_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= cardsDiscarded_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      cardsDiscarded_.WriteTo(output, _repeated_cardsDiscarded_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += cardsDiscarded_.CalculateSize(_repeated_cardsDiscarded_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DrawPokerRequest other) {
      if (other == null) {
        return;
      }
      cardsDiscarded_.Add(other.cardsDiscarded_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            cardsDiscarded_.AddEntriesFrom(input, _repeated_cardsDiscarded_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class PaytableList : pb::IMessage<PaytableList> {
    private static readonly pb::MessageParser<PaytableList> _parser = new pb::MessageParser<PaytableList>(() => new PaytableList());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PaytableList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protobuf.DrawPoker.DrawPokerMessagesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PaytableList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PaytableList(PaytableList other) : this() {
      paytables_ = other.paytables_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PaytableList Clone() {
      return new PaytableList(this);
    }

    /// <summary>Field number for the "Paytables" field.</summary>
    public const int PaytablesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Protobuf.DrawPoker.Paytable> _repeated_paytables_codec
        = pb::FieldCodec.ForMessage(10, global::Protobuf.DrawPoker.Paytable.Parser);
    private readonly pbc::RepeatedField<global::Protobuf.DrawPoker.Paytable> paytables_ = new pbc::RepeatedField<global::Protobuf.DrawPoker.Paytable>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protobuf.DrawPoker.Paytable> Paytables {
      get { return paytables_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PaytableList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PaytableList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!paytables_.Equals(other.paytables_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= paytables_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      paytables_.WriteTo(output, _repeated_paytables_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += paytables_.CalculateSize(_repeated_paytables_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PaytableList other) {
      if (other == null) {
        return;
      }
      paytables_.Add(other.paytables_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            paytables_.AddEntriesFrom(input, _repeated_paytables_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
